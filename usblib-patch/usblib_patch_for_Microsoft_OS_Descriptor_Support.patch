Index: firmware/ms_os_descriptor.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/firmware/ms_os_descriptor.c b/firmware/ms_os_descriptor.c
new file mode 100644
--- /dev/null	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
+++ b/firmware/ms_os_descriptor.c	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
@@ -0,0 +1,109 @@
+/*
+ * Lenlab, an oscilloscope software for the TI LaunchPad EK-TM4C123GXL
+ * Copyright (C) 2017-2021 Christoph Simon and the Lenlab developer team
+ * 
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "ms_os_descriptor.h"
+
+#include "usblib/device/usbdevice.h"
+
+
+#define USB_WINUSB_INTERFACE_NUM          0x00
+#define USB_MS_OS_VENDOR_CODE             0x23
+
+#define USB_TI_USB_DEV_BULK_IF_GUID       L"{0a3bd048-863e-4b88-8a49-e57eb4e2c67c}"
+#define USB_TI_USB_DFU_IF_GUID            L"{fd9372d1-ceb9-442a-8883-51c34a7bbba6}"
+
+
+// Microsoft OS String Descriptor
+static const tUSB_MS_OS_STRING_DESCRIPTOR USBMsftOSStringDesc = USB_MS_OS_STRING_DESCRIPTOR( USB_MS_OS_VENDOR_CODE );
+
+
+// MS Extended Compat ID OS Feature Descriptor
+#define MS_EXTENDED_COMPAT_FUNCTION_NUM   1
+
+
+typedef struct _MS_EXTENDED_COMPAT_ID_DESCRIPTOR
+{
+    tMS_EXTENDED_COMPAT_ID_HEADER   header;
+    tMS_EXTENDED_COMPAT_ID_FUNCTION function[ MS_EXTENDED_COMPAT_FUNCTION_NUM ];
+} PACKED tMS_EXTENDED_COMPAT_ID_DESCRIPTOR;
+
+
+static const tMS_EXTENDED_COMPAT_ID_DESCRIPTOR USBExtendedCompatIDDesc = {
+    .header   = MS_EXTENDED_COMPAT_ID_HEADER( sizeof( tMS_EXTENDED_COMPAT_ID_DESCRIPTOR ), MS_EXTENDED_COMPAT_FUNCTION_NUM ),
+    .function = { MS_EXTENDED_COMPAT_ID_FUNCTION( USB_WINUSB_INTERFACE_NUM, USB_COMPATID_WINUSB, USB_SUBCOMPATID_NONE ) }
+};
+
+
+// MS Extended Property OS Feature Descriptor
+typedef struct _MS_EXTENDED_PROPERTY_DESCRIPTOR
+{
+    tMS_EXTENDED_PROPERTY_HEADER         header;
+    tMS_EXTENDED_PROPERTY_INTERFACE_GUID property0;
+} PACKED tMS_EXTENDED_PROPERTY_DESCRIPTOR;
+
+
+static const tMS_EXTENDED_PROPERTY_DESCRIPTOR USBExtendedPropIfGUIDDesc = {
+    .header    = MS_EXTENDED_PROPERTY_HEADER( sizeof( tMS_EXTENDED_PROPERTY_DESCRIPTOR ), 0x0001 ),
+    .property0 = MS_EXTENDED_PROPERTY_INTERFACE_GUID( USB_TI_USB_DEV_BULK_IF_GUID )
+};
+
+
+bool
+MSOSDescriptorHandleStringRequest(uint8_t **ppui8EP0Data, volatile uint32_t *pui32EP0DataRemain, uint16_t ui16Lang, uint16_t ui16Index)
+{
+    if (ui16Index == USB_MS_OS_STRING_DESC_IDX) {
+        // Return the externally specified configuration descriptor.
+        *ppui8EP0Data = (uint8_t *) &USBMsftOSStringDesc;
+
+        // The total size of a string descriptor is in byte 0.
+        *pui32EP0DataRemain = sizeof( tUSB_MS_OS_STRING_DESCRIPTOR );
+
+        return true;
+    }
+
+    return false;
+}
+
+
+void
+MSOSDescriptorHandleVendorRequest(void *pvBulkDevice, tUSBRequest *pUSBRequest)
+{
+    uint32_t len;
+
+    if (       (pUSBRequest->bmRequestType == (USB_RTYPE_DIR_IN | USB_RTYPE_VENDOR) )
+            && (pUSBRequest->bRequest      == USB_MS_OS_VENDOR_CODE)
+//          && (pUSBRequest->wValue        == USB_WINUSB_INTERFACE_NUM)  // should be ignored
+            && (pUSBRequest->wIndex        == USB_MS_EXTENDED_COMPAT_ID_TYPE)
+       ) {
+        len = pUSBRequest->wLength < sizeof(USBExtendedCompatIDDesc) ? pUSBRequest->wLength : sizeof(USBExtendedCompatIDDesc);
+        USBDCDSendDataEP0( 0, (uint8_t *) &USBExtendedCompatIDDesc, len );
+    }
+
+    if (       (   (pUSBRequest->bmRequestType == (USB_RTYPE_DIR_IN | USB_RTYPE_VENDOR | USB_RTYPE_INTERFACE) )
+                || (pUSBRequest->bmRequestType == (USB_RTYPE_DIR_IN | USB_RTYPE_VENDOR) ) ) // workaround for Renesus USB3.0 driver
+            && (pUSBRequest->bRequest      == USB_MS_OS_VENDOR_CODE)
+            && (pUSBRequest->wValue        == USB_WINUSB_INTERFACE_NUM)
+            && (pUSBRequest->wIndex        == USB_MS_EXTENDED_PROPERTY_TYPE)
+       ) {
+        len = pUSBRequest->wLength < sizeof(USBExtendedPropIfGUIDDesc) ? pUSBRequest->wLength : sizeof(USBExtendedPropIfGUIDDesc);
+        USBDCDSendDataEP0( 0, (uint8_t *) &USBExtendedPropIfGUIDDesc, len );
+    }
+}
Index: firmware/ms_os_descriptor.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/firmware/ms_os_descriptor.h b/firmware/ms_os_descriptor.h
new file mode 100644
--- /dev/null	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
+++ b/firmware/ms_os_descriptor.h	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
@@ -0,0 +1,170 @@
+/*
+ * Lenlab, an oscilloscope software for the TI LaunchPad EK-TM4C123GXL
+ * Copyright (C) 2017-2021 Christoph Simon and the Lenlab developer team
+ * 
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#ifndef MS_OS_DESCRIPTOR_H_
+#define MS_OS_DESCRIPTOR_H_
+
+
+#include "usblib/usblib.h"
+
+
+//
+// Microsoft OS String Descriptor
+//
+
+#define USB_MS_OS_STRING_DESC_IDX 0xEE
+#define USB_MS_OS_STRING_DESC_SIGNATURE { 'M', 0, 'S', 0, 'F', 0, 'T', 0, '1', 0, '0', 0, '0', 0 }
+
+
+typedef struct _USB_MS_OS_STRING_DESCRIPTOR
+{
+    uint8_t  bLength;               // Length of the descriptor
+    uint8_t  bDescriptorType;       // Descriptor type
+    uint8_t  qwSignature[14];       // Signature field
+    uint8_t  bMS_VendorCode;        // Vendor code
+    uint8_t  bPad;                  // Pad field
+} PACKED tUSB_MS_OS_STRING_DESCRIPTOR;
+
+
+#define USB_MS_OS_STRING_DESCRIPTOR( vendor_code ) \
+{ \
+    .bLength         = sizeof(tUSB_MS_OS_STRING_DESCRIPTOR), \
+    .bDescriptorType = USB_DTYPE_STRING, \
+    .qwSignature     = USB_MS_OS_STRING_DESC_SIGNATURE, \
+    .bMS_VendorCode  = USB_MS_OS_VENDOR_CODE, \
+    .bPad            = 0x00 \
+}
+
+
+//
+// Microsoft Extended Compat ID OS Feature Descriptor
+//
+
+#define USB_MS_EXTENDED_COMPAT_ID_VERSION 0x0100
+#define USB_MS_EXTENDED_COMPAT_ID_TYPE 0x04
+
+#define USB_COMPATID_NONE {0}
+#define USB_SUBCOMPATID_NONE {0}
+#define USB_COMPATID_WINUSB "WINUSB\0"
+
+
+typedef struct _MS_EXTENDED_COMPAT_ID_HEADER
+{
+    uint32_t dwLength;              // length of the complete descriptors set
+    uint16_t bcdVersion;            // descriptor's version number (BCD: 0x0100)
+    uint16_t wIndex;                // type number of extended compat descriptor (0x04)
+    uint8_t  bCount;                // number of custom property sections
+    uint8_t  rgbReserved[7];        // reserved
+} PACKED tMS_EXTENDED_COMPAT_ID_HEADER;
+
+
+#define MS_EXTENDED_COMPAT_ID_HEADER( size, count ) \
+{ \
+    .dwLength       = size, \
+    .bcdVersion     = USB_MS_EXTENDED_COMPAT_ID_VERSION, \
+    .wIndex         = USB_MS_EXTENDED_COMPAT_ID_TYPE, \
+    .bCount         = count, \
+    .rgbReserved    = {0} \
+}
+
+
+typedef struct _MS_EXTENDED_COMPAT_ID_FUNCTION
+{
+    uint8_t  bFirstInterfaceNumber; // interface or function number
+    uint8_t  bReserved;             // reserved
+    uint8_t  compatibleID[8];       // function's compatible ID
+    uint8_t  subCompatibleID[8];    // function's subcompatible ID
+    uint8_t  rgbReserved[6];        // reserved
+} PACKED tMS_EXTENDED_COMPAT_ID_FUNCTION;
+
+
+#define MS_EXTENDED_COMPAT_ID_FUNCTION( interfaceNo, id, subID ) \
+{ \
+    .bFirstInterfaceNumber = interfaceNo, \
+    .bReserved             = 0x01, \
+    .compatibleID          = id, \
+    .subCompatibleID       = subID, \
+    .rgbReserved           = {0} \
+}
+
+
+//
+// Microsoft Extended Properties OS Feature Descriptor
+//
+
+#define USB_MS_EXTENDED_PROPERTY_VERSION 0x0100
+#define USB_MS_EXTENDED_PROPERTY_TYPE 0x05
+
+#define USB_EX_PROPERTY_REG_SZ            0x00000001  // NULL-terminated Unicode String
+#define USB_EX_PROPERTY_REG_EXPAND_SZ     0x00000002  // NULL-terminated Unicode String (environment var)
+#define USB_EX_PROPERTY_REG_BINARY        0x00000003  // Binary
+#define USB_EX_PROPERTY_REG_DWORD_LE      0x00000004  // little-endian 32-bit integer
+#define USB_EX_PROPERTY_REG_DWORD_BE      0x00000005  // big-endian 32-bit integer
+#define USB_EX_PROPERTY_REG_LINK          0x00000006  // NULL-terminated Unicode String (symbolic link)
+#define USB_EX_PROPERTY_REG_MULTI_SZ      0x00000007  // Multi NULL-terminated Unicode String
+
+#define USB_EX_PROPERTY_DATA_LEN_DWORD 4
+
+
+typedef struct _MS_EXTENDED_PROPERTY_HEADER
+{
+    uint32_t dwLength;              // length of the complete descriptors set
+    uint16_t bcdVersion;            // descriptor's version number (BCD: 0x0100)
+    uint16_t wIndex;                // type number of extended property desc (0x05)
+    uint16_t wCount;                // number of custom property sections
+} PACKED tMS_EXTENDED_PROPERTY_HEADER;
+
+
+#define MS_EXTENDED_PROPERTY_HEADER( size, count ) \
+{ \
+    .dwLength   = size, \
+    .bcdVersion = USB_MS_EXTENDED_PROPERTY_VERSION, \
+    .wIndex     = USB_MS_EXTENDED_PROPERTY_TYPE, \
+    .wCount     = count \
+}
+
+
+// DeviceInterfaceGUID - interface GUID for WinUSB
+
+#define USB_EX_PROPERTY_NAME_LENGTH_IFGUID 0x0028
+#define USB_EX_PROPERTY_DATA_LEN_IFGUID 0x0000004E
+
+
+typedef struct _MS_EXTENDED_PROPERTY_INTERFACE_GUID
+{
+    uint32_t dwSize;                // size of this section
+    uint32_t dwPropertyDataType;    // property data format
+    uint16_t wPropertyNameLength;   // property name length
+    uint16_t bPropertyName[USB_EX_PROPERTY_NAME_LENGTH_IFGUID / sizeof(uint16_t)];   // property name
+    uint32_t dwPropertyDataLength;  // length of property data
+    uint16_t bPropertyData[USB_EX_PROPERTY_DATA_LEN_IFGUID / sizeof(uint16_t)];      // property data
+} PACKED tMS_EXTENDED_PROPERTY_INTERFACE_GUID;
+
+
+#define MS_EXTENDED_PROPERTY_INTERFACE_GUID( guid ) \
+{ \
+    .dwSize               = sizeof( tMS_EXTENDED_PROPERTY_INTERFACE_GUID ), \
+    .dwPropertyDataType   = USB_EX_PROPERTY_REG_SZ, \
+    .wPropertyNameLength  = USB_EX_PROPERTY_NAME_LENGTH_IFGUID, \
+    .bPropertyName        = L"DeviceInterfaceGUID", \
+    .dwPropertyDataLength = USB_EX_PROPERTY_DATA_LEN_IFGUID, \
+    .bPropertyData        = guid \
+}
+
+
+#endif /* MS_OS_DESCRIPTOR_H_ */
Index: firmware/usblib/device/usbdbulk.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/firmware/usblib/device/usbdbulk.c b/firmware/usblib/device/usbdbulk.c
--- a/firmware/usblib/device/usbdbulk.c	(revision 0eb3246e28f52e89f06330a4a04ed5f3b65f8b3c)
+++ b/firmware/usblib/device/usbdbulk.c	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
@@ -96,7 +96,9 @@
 {
     18,                         // Size of this structure.
     USB_DTYPE_DEVICE,           // Type of this structure.
-    USBShort(0x110),            // USB version 1.1 (if we say 2.0, hosts assume
+    USBShort(0x200),            // PATCH for Microsoft OS Descriptor Support
+                                // MS OS Descriptor works with 2.0 only
+    //USBShort(0x110),          // USB version 1.1 (if we say 2.0, hosts assume
                                 // high-speed - see USB 2.0 spec 9.2.6.6)
     USB_CLASS_VEND_SPECIFIC,    // USB Device Class
     0,                          // USB Device Sub-class
@@ -326,6 +328,9 @@
 static void HandleDevice(void *pvBulkDevice, uint32_t ui32Request,
                          void *pvRequestData);
 
+// PATCH for Microsoft OS Descriptor Support
+extern void MSOSDescriptorHandleVendorRequest(void *pvBulkDevice, tUSBRequest *pUSBRequest);
+
 //*****************************************************************************
 //
 // Device event handler callbacks.
@@ -341,7 +346,8 @@
     //
     // RequestHandler
     //
-    0,
+    // PATCH for Microsoft OS Descriptor Support
+    MSOSDescriptorHandleVendorRequest,
 
     //
     // InterfaceChange
Index: firmware/usblib/device/usbdenum.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/firmware/usblib/device/usbdenum.c b/firmware/usblib/device/usbdenum.c
--- a/firmware/usblib/device/usbdenum.c	(revision 0eb3246e28f52e89f06330a4a04ed5f3b65f8b3c)
+++ b/firmware/usblib/device/usbdenum.c	(revision 94924b9271f6da278daef9b04908afdf24027d6f)
@@ -2056,6 +2056,15 @@
         //
         case USB_DTYPE_STRING:
         {
+            // PATCH for Microsoft OS Descriptor Support
+            // Handle request for string descriptor at index 0xEE
+            extern bool MSOSDescriptorHandleStringRequest(uint8_t **ppui8EP0Data, volatile uint32_t *pui32EP0DataRemain, uint16_t ui16Lang, uint16_t ui16Index);
+
+            if (MSOSDescriptorHandleStringRequest(&psUSBControl->pui8EP0Data, &psUSBControl->ui32EP0DataRemain, psUSBRequest->wIndex, psUSBRequest->wValue & 0xFF))
+            {
+                break;
+            }
+
             //
             // Determine the correct descriptor index based on the requested
             // language ID and index.
